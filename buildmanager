#!/usr/local/products/expect/current/bin/expectk -f

if { [info exists env(BUILDMANAGER_DIR)] } {
     set dir $env(BUILDMANAGER_DIR)
} else {
     set dir .
}
source ${dir}/sessionwin_gui.tcl
source ${dir}/sessionwin_util.tcl
source ${dir}/menubar_gui.tcl
source ${dir}/customcmd_gui.tcl
source ${dir}/passwd_popup.tcl
source ${dir}/menu_util.tcl

set loginok 0
proc getlogininfo { reason } {
     global logname password
     global loginok
     global login_reason

     set login_reason $reason
     if { "passwd_popup" == [ info command passwd_popup ]} {
         passwd_popup .pop 
	 tkwait window .pop
	 set loginok 1
     } else {
	 puts -nonewline "login: "
	 flush stdout
	 gets stdin logname
	 exec stty -echo
	 puts -nonewline "password: "
	 flush stdout
	 gets stdin password
	 exec stty echo
    }
}


set bwcount 0

proc updateflavorbuttons { w w2 } {
    global os_dat bwcount

    foreach flavor $os_dat(LIST) {
        incr bwcount
        set bw $w.b_$bwcount

        if { ![info exists os_dat(f2bw,$flavor)] } {
	    checkbutton $bw -text "$flavor" \
		    -variable "os_dat(do,$flavor)" \
		    -command "updatehostwindows $w2"
	    pack $bw -side left
	    set os_dat(f2bw,$flavor) $bw
	}
    }
}

set hwcount 0
set sessionlist {}

proc updatehostwindows { w } {
    global os_dat sw_dat
    global hwcount
    global loginok

    # skip if we don't have passwords, etc. yet

    if { ! $loginok } {
	return
    }
    set newsessions {}

    foreach flavor $os_dat(LIST) {
        incr hwcount
	set hw $w.h_$hwcount

	# if we should be doing this flavor, but arent, add a window
	# for it

	if { $os_dat(do,$flavor) && ![info exists os_dat(f2w,$flavor)]} {
	    set h $os_dat(HOST,$flavor)
	    set os_dat(f2w,$flavor) $hw
	    set os_dat(w2f,$hw) $flavor

	    sessionwin $hw $h
	    pack $hw -expand 1 -fill both -side bottom

	    set s $sw_dat(w2s,$hw)
    	    set os_dat(s2f,$s) $flavor
	    $hw.l4 configure -text "$flavor"
	    lappend newsessions $s
	}

	# if we are doing this flavor, but shoudn't be anymore,
	# drop the session

	if { !$os_dat(do,$flavor) && [info exists os_dat(f2w,$flavor)]} {
	    drop_session $sw_dat(w2s,$os_dat(f2w,$flavor))
	}
    }

    # log in any new sessions

    loginsessions $newsessions
}

proc login_host { s host {depth  0}} {
    global logname password expect_out

    set spawn_id $s
    expect -re {.*:} 
    update_bytes
    exp_send "\r"
    expect ogin:    
    update_bytes
    exp_send "$logname\r"
    expect word:    
    update_bytes
    exp_send "$password\r"
    expect -re "\n(.*)\n"
    update_bytes
    if [catch {set resp $expect_out(1,string)}] {
	set resp "huh"
    }
    puts "resp is $resp"
    if { [ regexp {[Ii]ncorrect|[In]valid|[Uu]nkown|[Uu]nable} $resp ] } {
	if { $depth < 4 } {
	    getlogininfo "Login failed on host $host, please re-enter login info"
	    login_host $s $host [expr $depth + 1 ]
	} else {
	    drop_session $s
	}
    }
}

proc login_phase2 { s host } {
    global promptre logname password expect_out

    # now try to get the right prompt.  We could get asked for a
    # password again if the users account does a klog or something.
    # puts "expecting many things..."
    set timeout 60
    set spawn_id $s

    expect  {
	"ssword:"	{update_bytes; exp_send -i $s "$password\r";exp_continue }
	{Last login}	{update_bytes; exp_continue}
	timeout		{exp_continue}
	-re $promptre	{update_bytes}
    }

    exp_send "exec /bin/sh\r"

    # puts "setting prompt..."
    expect    -re $promptre
    update_bytes

    exp_send  "PS1='<$host> '\r"
    expect    "<$host> '"
    update_bytes

    # puts "we think we have a prompt again"
    expect -re $promptre
    update_bytes
    exp_send "\r"

    if {[info exists os_dat(INIT_COMMANDS)]} {
	foreach cmd $os_dat(INIT_COMMANDS) {
	    exp_send "$cmd\r"
	    expect -re $promptre
	    update_bytes
	}
    }

    exp_send "\r"
}

proc login_phase3 { s host } {
    global promptre logname password expect_out spawn_id
    global sw_dat
    global os_dat
    global env
   
    set spawn_id $s

    set flavor $os_dat(s2f,$s)
    # puts "expecting another prompt"
    expect -re $promptre
    update_bytes

    if {[info exists os_dat(PATH,$flavor)]} {
        exp_send "PATH=$os_dat(PATH,$flavor):\$PATH; export PATH\r"
    }

    if {[info exists os_dat(ENVVARS)]} {
	foreach var $os_dat(ENVVARS) {
	    if { [info exists env($var)] } {
		expect -re $promptre
		update_bytes
		exp_send "$var='$env($var)'; export $var\r"
	    } else {
		puts stderr "Warning: environment variable $var not set!"
	    }
	}
    }

    if {[info exists os_dat(COMMANDS)]} {
	foreach cmd $os_dat(COMMANDS) {
	    expect -re $promptre
	    update_bytes
	    exp_send "$cmd\r"
	}
    }
    if {[info exists os_dat(PLAT_COMMANDS,$flavor)]} {
	foreach cmd $os_dat(PLAT_COMMANDS,$flavor) {
	    expect -re $promptre
	    update_bytes
	    exp_send "$cmd\r"
	}
    }

    expect -re $promptre
    update_bytes
    exp_send "set -x\r"

    expect -re $promptre
    update_bytes
    exp_send [cmd_substitute "test -d  %d || mkdir -p %d\r" $s]
}

proc loginsessions  { newsessions } {
    global sessionlist sw_dat

    #
    # broken into phases to use long delay between entering password
    # and finishing .profile type stuff to start login of other hosts
    #
    foreach phase {host phase2 phase3} {
	foreach s $newsessions {
	    setstatus $s Login
	    login_$phase $s $sw_dat(s2h,$s)
	}
    }
}

proc update_bytes {} {
    global expect_out sw_dat

    rcvchars $sw_dat(s2w,$expect_out(spawn_id)) $expect_out(buffer)
}

proc update_status { status} {
    global expect_out sw_dat pending1 pending2

    update_bytes
    set s $expect_out(spawn_id)
    setstatus $s $status
    if { $status == "Ready" && [info exists pending1($s)] } {
	catch $pending1($s)
	unset pending1($s)
    }
    if { $status == "Ready" && [info exists pending2($s)] } {
	catch $pending2($s)
	unset pending2($s)
    }
}

proc drop_session { s } {
    global sessionlist sw_dat os_dat

    set w $sw_dat(s2w,$s)
    set flavor $os_dat(w2f,$w)
    set os_dat(do,$flavor) 0
    unset os_dat(w2f,$w)
    unset os_dat(f2w,$flavor)
    catch "destroy $w"
    set index [lsearch -exact $sessionlist $s]
    set sessionlist [lreplace $sessionlist $index $index]
    return [llength $sessionlist]
}

proc update_state {state} {
    global expect_out sw_dat statepending

    update_bytes
    set s $expect_out(spawn_id)
    setstate $s $state
    if { [info exists statepending($s,$state)] } {
	catch $statepending($s,$state)
	unset $statepending($s,$state)
    }
}

proc cmd_substitute {string s} {
    global product version releasetarget
    global os_dat sw_dat

    set result $string
    set productroot [productroot $os_dat(s2f,$s)]
    set dirname [file dirname $productroot]
    set tail [file tail $productroot]
    regsub -all {%D} $result $productroot result
    regsub -all {%d} $result $dirname result
    regsub -all {%T} $result $tail result
    regsub -all {%F} $result $os_dat(s2f,$s) result
    regsub -all {%H} $result $sw_dat(s2h,$s) result
    regsub -all {%W} $result $sw_dat(s2w,$s) result
    regsub -all {%P} $result $product result
    regsub -all {%V} $result $version result
    regsub -all {%R} $result $releasetarget result
    return $result
}

proc cmd_parallel { string {list {}} } {
    global sessionlist os_dat global history histslot

    .cmd.e delete 0 end
    .cmd.e insert 0 $string
    if { "$list" == "" } {
	set list $sessionlist
    }
    foreach s $list {
	set result [cmd_substitute $string $s]
	exp_send -i $s "$result\r"
    }
    lappend history $string
    set histslot [llength $history]
    # puts "history is $history"
}

proc cmd_taketurns { string {list {xxxxxxxxxx}} } {
    global pending1 pending2 sessionlist history histslot

    .cmd.e delete 0 end
    .cmd.e insert 0 $string
    if { "$list" == "" } {
        lappend history $string
        set histslot [llength $history]
        # puts "history is $history"
	return
    }
    if { "$list" == "xxxxxxxxxx" } {
	set list $sessionlist
    }
    set s [lindex $list 0]
    set list [lrange $list 1 end]
    set pending1($s) [list cmd_taketurns $string $list]
    set result [cmd_substitute $string $s]
    exp_send -i $s "$result\r"
}

proc cmd_previous {} {
    global history histslot

    set histslot [ expr $histslot - 1 ]
    .cmd.e delete 0 end
    .cmd.e insert 0 [lindex $history $histslot]
}

proc cmd_next {} {
    global history histslot
    
    incr histslot
    .cmd.e delete 0 end
    .cmd.e insert 0 [lindex $history $histslot]
}

proc getconfiginfo {} {
    global env

    if { ! [info exists env(BUILDMANAGER_DIR)] } {
	set env(BUILDMANAGER_DIR) ~/.buildmanager
    }
    set fd [open "|domainname" "r" ]
    gets $fd domain
    close $fd

    set configfiles [list 	$env(BUILDMANAGER_DIR)/lib/system.cfg	\
    			 	$env(BUILDMANAGER_DIR)/lib/site.cfg	\
    			 	$env(BUILDMANAGER_DIR)/lib/$domain.cfg \
				~/.buildmanagerrc ]

    foreach f $configfiles {
	if { [file exists $f] } {
	    puts "getting config info from $f"
	    uplevel #0 "source $f"
	}
    }
}

# ----------------------------------------------------------------------
# mainline...
# ----------------------------------------------------------------------

proc init {} {
    global argv env spawn_id history histslot expect_out pending pending2
    global os_dat sw_dat
    global promptre product version 
       
    if { [lindex $argv 0] == "-verbose" } {
	set argv [lrange $argv 1 end]
    } else {
	log_user 0
    }

    getconfiginfo

    if { [llength $argv ] > 0} {
	set product [lindex $argv 0]
    } 
    if { [llength $argv ] > 1} {
	set version [lindex $argv 1]
    }
    # puts "product $product version $version"

    set history {}
    set histslot 0

    menubar_gui .menubar
    fill_in_cmd_menu .menubar
    customcmd_gui .cmd
    frame .flavors
    frame .hosts
    pack .menubar .cmd .flavors -side top -expand 0 -fill x
    pack .hosts .cmd -side top -expand 1 -fill both

    updateflavorbuttons .flavors .hosts 
    getlogininfo "Initial login"
    updatehostwindows .hosts
}

proc expect_loop {} {
    global argv env spawn_id history histslot expect_out pending pending2
    global os_dat sw_dat
    global promptre makestartre makefailre sessionlist

    expect {
	-i sessionlist -re $makestartre { 
	    set s $expect_out(spawn_id)

	    puts "saw makestart string on $s"

	    set args "$expect_out(1,string)"

	    if { [ regexp {.* ([^- =]+) } $args match first ] } {
		 # if we have a last argument with no dashes or equals...
		 set target $first
	    } else {
		 set target "all"
	    }
	    update_state $target
	    set pending2($s) "update_state \"$target-OK\""
	    exp_continue
	}
	-i sessionlist -re $makefailre {
	    set s $expect_out(spawn_id)
	    puts "saw makefail string on $s"
	    set pending2($s) "update_state \"$sw_dat(state,$s)-Failed\""
	    update_bytes
	    exp_continue
	}
	-i sessionlist -re $promptre { 
	    update_status Ready
	    exp_continue
	}
	-i sessionlist -re "\[\r\n\]+" {
	    update_status Running
	    exp_continue
	}
	-i sessionlist -re "\[^\r\n\]+" { 
	    update_bytes
	    exp_continue
	}
	-i sessionlist timeout {
	    flush_sent $sw_dat(s2w,$expect_out(spawn_id))
	    flush_rcvd $sw_dat(s2w,$expect_out(spawn_id))
	    exp_continue
	}
	-i sessionlist eof {
	    if [drop_session $expect_out(spawn_id)] exp_continue
	}
    }
}

proc error_dialog {routine message} {
    global errorInfo

    set res [tk_dialog .error "Error!" "Error in $routine: $message" {} 0 "Ok" "Info"]
    if {$res == 1} {
	puts $errorInfo
    }
}

proc main {} {
    init 
    while [ catch expect_loop result] {
	error_dialog event_loop $result 
    }
    exit
}

main
