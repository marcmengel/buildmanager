# build product area

#defaults
set product "demo"
set version "v2_0"
set releasetarget "kits"

proc productroot { flavor } {
    global product version

    return "/fnal/ups/${product}/${version}/${flavor}"
}

#
# A more complicated example would be something like:
#
# proc productroot { flavor } {
#     global product version
#     if { $product == "fred" && $version != "v9_17" } {
#         return "/tmp/special/fred/$version"
#     } elsif { $product == "joe" && [string match $flavor "IRIX*"] } {
#         return "/tmp/IRIXjunk/$version"
#     } else {
#         return "/tmp/${product}-${version}-${flavor}"
#     }
# }
#

# ------------------------------------------------------------------
# Regular Expressions for Various Purposes
#

# -----
# regexp to match a prompt -- something ending with a > % $ # or ? 
# followed by a blank.
# -- amended to be $%# with a space, or a non-dash followed by
#    a space so ls -l output doesn't give us the heebie geebies
set promptre {[$%#] $|[^-]> $}

#
# any of errorlist or cmdstartre stuff should match
# this simpler pattern, which since it starts with all
# "rarer" characters (punctuation) should match faster
#
set allwatchre {[+:*] [0-9a-zA-Z -]+|\(i[a-z ]*|'n[a-z ]*}

# -----
# regexp to match a "set -x" echo-ed make command
set cmdstartre  "\\+ (\[a-zA-Z0-9_\]+)(\[^\n\r\]*)"

# -----
# regexp to match a failed make, cat, or sed
set errorlist {
	{: [a-zA-Z0-9 -]+ [Ee]rror:}
	{'t know how}
	{\* [Ee][a-z]* code [^0]}
	{\* [][a-zA-Z]* Exit [^0]}
	{\* [][a-zA-Z]* Error [^0]}
	{\* [nN]o rule to make}
	{[Uu]nrecognized command:}
	{[Gg]arbled command:}
	{end of file from server}
	{: \[.* aborted\]:}
	{: *[-0-9 a-z]*[Cc]cannot open}
	{: *[-0-9 a-z]*[Cc]cannot find}
	{: *[-0-9 a-z]*[dD]oes not exist}
	{: *[-0-9 a-z]*[Nn]ot found}
	{: *[-0-9 a-z]*[Nn]o such [fd]i[lr]}
	{: *[-0-9 a-z]*[tT]he error code}
}
set cmdfailre [join $errorlist "|"]

# -----
# regexp to detect that make or cvs ignored an error...
set nevermindlist {
	{[Ii]gnored}
	{will refetch}
	{will still be declared}
}
set cmdnevermindre [join $nevermindlist "|"]

# -----
# regexp to notice a question: last one checks for echo "...\c" with
#    the \c being printed...

set questionre {\? $|\? \\c$}

# ------------------------------------------------------------------
# Operating System specifics
#

# operating systems to run on
set os_dat(LIST)  {OSF1+V3 OSF1+V4 IRIX+5.3 IRIX+6.2 IRIX+6.5  Linux+2 SunOS+5 AIX+3.2 AIX+4.1 CYGWIN32_NT}
# set os_dat(LIST)  {OSF1+V3 IRIX+5 SunOS+5 AIX+3}

# hosts for each operating system
set os_dat(HOST,AIX+3)	 unknown
set os_dat(HOST,AIX+4)	 unknown
set os_dat(HOST,IRIX+5)	 unknown
set os_dat(HOST,IRIX+6)	 unknown
set os_dat(HOST,OSF1+V3) unknown
set os_dat(HOST,OSF1+V4) unknown
set os_dat(HOST,SunOS+5) unknown
set os_dat(HOST,Linux+2) unknown

# path additions for each system , so we can find compilers, X libraries
# etc.
set os_dat(PATH,AIX+3)   "/usr/bin/X11:/usr/lpp/X11/Xamples/bin:/usr/local/bin"
set os_dat(PATH,AIX+4)   "/usr/bin/X11:/usr/lpp/X11/Xamples/bin:/usr/local/bin"
set os_dat(PATH,IRIX+5)  "/usr/X11/bin:/usr/bsd:/usr/ccs/bin:/usr/local/bin"
set os_dat(PATH,IRIX+6)  "/usr/bin/X11:/usr/ccs/bin:/usr/local/bin:/usr/bsd/bin"
set os_dat(PATH,SunOS+5) "/opt/SUNWspro/bin:/bin:/usr/bin:/usr/ccs/bin:/usr/ucb:/usr/openwin/bin:/usr/local/bin"
set os_dat(PATH,SunOS+6) "/opt/SUNWspro/bin:/bin:/usr/bin:/usr/ccs/bin:/usr/ucb:/usr/openwin/bin:/usr/local/bin"
set os_dat(PATH,OSF1+V3) "/sbin:/usr/ccs/bin:/usr/local/bin"
set os_dat(PATH,OSF1+V4) "/sbin:/usr/ccs/bin:/usr/local/bin"
set os_dat(PATH,Linux+2) "/bin:/sbin:/usr/bin:/usr/local/bin:/usr/X11R6/bin"


#
# Environment variables to pass in
#
set os_dat(ENVVARS)	{CVSROOT}

#
# some items to make life easier
# -- standardize erase character, since we controll what backspace/del
#    keys do
# -- make shell functions for screen editors that launch an xterm
# -- setup so setups work
#
set os_dat(COMMANDS)	{
	{stty erase '^?' intr '^c' kill '^u'}
	{setup cvs}
	{setup upd}
}

foreach f $os_dat(LIST)  {
   set os_dat(PLAT_COMMANDS,$f) "{bm_setenv F $f}"
}
lappend os_dat(PLAT_COMMANDS,CYGWIN32_NT) \
	{source /.bashrc}
lappend os_dat(PLAT_COMMANDS,SunOS+5) \
	{bm_setenv OPENWINHOME "/usr/openwin"}

lappend os_dat(PLAT_COMMANDS,IRIX+6) \
	{bm_setenv SGI_ABI -n32}

array set cmd_menu {
    { 1. cd}	 	{cmd_parallel  "cd %D"}
    { 2. cvs export}	{cmd_taketurns "cd %d; cvs export -r %V -d %T %P" }
    { 3. cvs checkout}	{cmd_parallel  "cd %d; cvs co -r %V -d %T -A %P" }
    { 4. make build_n_test} {cmd_parallel "(cd %D; make build_n_test)"}
    { 5. setup -q build?}	{cmd_parallel  "cd %D; setup -q 'build?' -r `pwd` -M ./ups -m %P.table %P"}
    { 6. setup}	  	{cmd_parallel  "cd %D; setup  -r `pwd` -M ./ups -m %P.table %P"}
    { 7. make declare}	{cmd_taketurns "(cd %D; make declare)"}
    { 8. make all}	  	{cmd_parallel  "(cd %D; make all)"}
    { 9. make test}	  	{cmd_parallel  "(cd %D; make test)"}
    {10. make clean}	{cmd_parallel  "(cd %D; make clean)"}
    {11. make kits}  	{cmd_taketurns "(cd %D; make kits)"}
    {12. make local}  	{cmd_taketurns "(cd %D; make local)"}
    {13. remove source}	{cmd_parallel  "cd %d; rm -rf %T"}
    {14. cvs update}	{cmd_parallel "(cd %D; cvs update -d)"}
    {15. cvs update -A}	{cmd_parallel "(cd %D; cvs update -A)"}
    {17. clear auto}	{clear_statepending}
    {18. interrupt}	  	{cmd_parallel  "\x003"}
    {19. exit} 		{cmd_parallel  "exit"; after 5000 exit}
}
