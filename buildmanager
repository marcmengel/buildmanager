#!/bin/env expectk

if { [info exists env(BUILDMANAGER_DIR)] } {
     set dir $env(BUILDMANAGER_DIR)
} else {
     set dir .
}
source ${dir}/sessionwin_gui.tcl
source ${dir}/sessionwin_util.tcl
source ${dir}/menubar_gui.tcl
source ${dir}/customcmd_gui.tcl
source ${dir}/passwd_popup.tcl
source ${dir}/menu_util.tcl
source ${dir}/html_text.tcl
source ${dir}/cmd_machine.tcl
source ${dir}/scrollframe.tcl

set loginok 0

proc getlogininfo { reason } {
     global logname password
     global loginok
     global login_reason
     global logininfoflag

     set login_reason $reason
     if { "passwd_popup" == [info command passwd_popup]} {
	 update
	 passwd_popup .pop
	 tkwait window .pop
     } else {
	 puts $reason
	 puts -nonewline "login: "
	 flush stdout
	 gets stdin logname
	 exec stty -echo
	 puts -nonewline "password: "
	 flush stdout
	 gets stdin password
	 exec stty echo
	 puts ""
	 flush stdout
    }
    set loginok 1
}

set bwcount 0

proc updateflavorbuttons { w w2 } {
    global os_dat bwcount

    foreach flavor $os_dat(LIST) {
        incr bwcount
        set bw $w.b_$bwcount

        if { ![info exists os_dat(f2bw,$flavor)] } {
	    checkbutton $bw -text "$flavor" \
		    -variable "os_dat(do,$flavor)" \
		    -command "updatehostwindows $w2" \
		    -selectcolor green
	    pack $bw -side left
	    set os_dat(f2bw,$flavor) $bw
	}
    }
}

set hwcount 0
set sessionlist {}

proc updatehostwindows { w } {
    global os_dat sw_dat
    global hwcount
    global loginok

    # skip if we don't have passwords, etc. yet

    if { ! $loginok } {
	return
    }
    set newsessions {}

    foreach flavor $os_dat(LIST) {
        incr hwcount
	set hw $w.h_$hwcount

	# if we should be doing this flavor, but arent, add a window
	# for it

	if { $os_dat(do,$flavor) && ![info exists os_dat(f2w,$flavor)]} {
	    set h $os_dat(HOST,$flavor)
	    set os_dat(f2w,$flavor) $hw
	    set os_dat(w2f,$hw) $flavor

	    sessionwin $hw $h
	    pack $hw -expand 1 -fill both -side bottom

	    set s $sw_dat(w2s,$hw)
    	    set os_dat(s2f,$s) $flavor
	    $hw.l4 configure -text "$flavor"
	    lappend newsessions $s
	}

	# if we are doing this flavor, but shoudn't be anymore,
	# drop the session

	if { !$os_dat(do,$flavor) && [info exists os_dat(f2w,$flavor)]} {
	    drop_session $sw_dat(w2s,$os_dat(f2w,$flavor))
	}
    }

    # log in any new sessions

    newloginsessions $newsessions
}

proc set_everything_state { win state } {
    if { [winfo class $win] != "Text" } {
        catch {$win configure -state $state} 
	catch {$win configure -foreground [$win cget -foreground]} 
    }
    foreach kid [winfo children $win] {
	set_everything_state $kid $state
    }
}

proc newloginsessions { newsessions } {
    global logname password expect_out timeout
    global promptre
    global sessionlist sw_dat os_dat
    global env
    global logsessions

    set_everything_state . disabled

    if {[info exists os_dat(ENVVARS)]} {
	foreach var $os_dat(ENVVARS) {
	    if { ![info exists env($var)] } {
		puts "buildmanager: warning, $var not set to pass through!"
	    }
	}
    }

    # build up sequence of commands to type in

    foreach s $newsessions {
        set w $sw_dat(s2w,$s)
        set flavor $os_dat(w2f,$w)
	set cmdlist($s) {}
	lappend cmdlist($s) "exec /bin/sh"
	lappend cmdlist($s) "PS1='<$sw_dat(s2h,$s)> '"
        if {[info exists os_dat(INIT_COMMANDS)]} {
	    foreach cmd $os_dat(INIT_COMMANDS) { 
		lappend cmdlist($s) $cmd
	    }
	}
        if {[info exists os_dat(PATH,$flavor)]} {
  	    lappend cmdlist($s) "PATH=$os_dat(PATH,$flavor):\$PATH; export PATH"
	}

	if {[info exists os_dat(ENVVARS)]} {
	    foreach var $os_dat(ENVVARS) {
		if { [info exists env($var)] } {
		    lappend cmdlist($s)  "$var='$env($var)'; export $var"
		}
	    }
	}
	if {[info exists os_dat(COMMANDS)]} {
	    foreach cmd $os_dat(COMMANDS) {
		lappend cmdlist($s) $cmd
	    }
	}
	if {[info exists os_dat(PLAT_COMMANDS,$flavor)]} {
	    foreach cmd $os_dat(PLAT_COMMANDS,$flavor) {
		lappend cmdlist($s) $cmd
	    }
	}
	lappend cmdlist($s) "set -x"
	set ncmds($s) [llength $cmdlist($s)]
	set curcmd($s) 0
	set logfails($s) 0
	setstatus $s Login
    }

    set logfail {([Ii]ncorrect|[In]valid|[Uu]nkown|[Uu]nable)}
    set timesasked 0
    
    set logsessions $newsessions
    set loginfailed 1

    while {[llength $logsessions] > 0} {
        set loginfailed 0
	expect {
	    -i logsessions -re {ast login: } {
		    update_bytes
		    exp_continue 
	    }
	    -i logsessions -re {ogin: $} 	 { 
		    set s $expect_out(spawn_id)
		    update_bytes
		    exp_send -i $s "$logname\r"
		    exp_continue 
	    }
	    -i logsessions -re {word: ?$} 	 { 
		    set s $expect_out(spawn_id)
		    update_bytes
		    exp_send -i $s "$password\r"
		    exp_continue 
	    }
	    -i logsessions -re $logfail	 {
		update_bytes
		set s $expect_out(spawn_id)
		set host $sw_dat(s2h,$s)


		set loginfailed $s
	    }
	    -i logsessions -re $promptre	 { 

		set s $expect_out(spawn_id)
		update_bytes
		exp_send -i $s "[lindex $cmdlist($s) $curcmd($s)]\r"
		setstatus $s "Setup - $curcmd($s)"
		incr curcmd($s)
		if { $curcmd($s) > $ncmds($s) } {
		    set index [lsearch -exact $logsessions $s]
		    set logsessions [lreplace $logsessions $index $index]
		}
		if {[llength $logsessions] > 0} {
		    exp_continue
		}
	    }
	    -i logsessions -re "\[\r\n\]+"	{ 
		    update_bytes
		    exp_continue
	    }
	    -i logsessions timeout	 { 
		    exp_continue
	    }
	    -i logsessions eof	 { 
		set s $expect_out(spawn_id)
		set host $sw_dat(s2h,$s)

		puts "lost connection on host $host"
		set index [lsearch -exact $logsessions $s]
		set logsessions [lreplace $logsessions $index $index]
		drop_session $s
		if {[llength $logsessions] > 0} {
		    exp_continue
		}
	    }
	}
	if {$loginfailed != 0 } {
	    set s $loginfailed
	    incr logfails($s)

	    if {$logfails($s) < 4 } {

		if {$logfails($s) > $timesasked } {
		    incr timesasked
		    sleep 1
		    update
	            getlogininfo "Login failed on host $host, please re-enter login info"
		}

	    } else {
		puts "login failed repeatedly on host $host"
                set index [lsearch -exact $logsessions $s]
                set logsessions [lreplace $logsessions $index $index]
		drop_session $s
	    }
	}
    }
    set_everything_state . enabled
}

proc update_bytes {} {
    global expect_out sw_dat

    if {[info exists expect_out(spawn_id)]} {
       rcvchars $sw_dat(s2w,$expect_out(spawn_id)) $expect_out(buffer)
    }
}

proc update_status { status } {
    global expect_out sw_dat pending1 pending2

    update_bytes
    set s $expect_out(spawn_id)
    setstatus $s $status
    if { $status == "Ready" && [info exists pending1($s)] } {
	catch $pending1($s)
	unset pending1($s)
    }
    if { $status == "Ready" && [info exists pending2($s)] } {
	catch $pending2($s)
	unset pending2($s)
    }
}

proc drop_session { s } {
    global sessionlist sw_dat os_dat

    set w $sw_dat(s2w,$s)
    set flavor $os_dat(w2f,$w)
    set os_dat(do,$flavor) 0
    unset os_dat(w2f,$w)
    unset os_dat(f2w,$flavor)
    catch "destroy $w"
    set index [lsearch -exact $sessionlist $s]
    set sessionlist [lreplace $sessionlist $index $index]
    return [llength $sessionlist]
}

proc cmd_substitute {string s} {
    global product version releasetarget
    global os_dat sw_dat

    set result $string
    set productroot [productroot $os_dat(s2f,$s)]
    set dirname [file dirname $productroot]
    set tail [file tail $productroot]
    regsub -all {%D} $result $productroot result
    regsub -all {%d} $result $dirname result
    regsub -all {%T} $result $tail result
    regsub -all {%F} $result $os_dat(s2f,$s) result
    regsub -all {%H} $result $sw_dat(s2h,$s) result
    regsub -all {%W} $result $sw_dat(s2w,$s) result
    regsub -all {%P} $result $product result
    regsub -all {%V} $result $version result
    regsub -all {%R} $result $releasetarget result
    return $result
}

proc cmd_parallel { string {list {}} } {
    global sessionlist os_dat global history histslot

    .cmd.e delete 0 end
    .cmd.e insert 0 $string
    .cmd.e selection range 0 end
    if { "$list" == "" } {
	set list $sessionlist
    }
    foreach s $list {
	set result [cmd_substitute $string $s]
	exp_send -i $s "$result\r"
    }
    lappend history $string
    set histslot [llength $history]
    # puts "history is $history"
}

proc cmd_taketurns { string {list {xxxxxxxxxx}} } {
    global pending1 pending2 sessionlist history histslot

    .cmd.e delete 0 end
    .cmd.e insert 0 $string
    .cmd.e selection range 0 end
    if { "$list" == "" } {
        lappend history $string
        set histslot [llength $history]
        # puts "history is $history"
	return
    }
    if { "$list" == "xxxxxxxxxx" } {
	set list $sessionlist
    }
    set s [lindex $list 0]
    set list [lrange $list 1 end]
    set pending1($s) [list cmd_taketurns $string $list]
    set result [cmd_substitute $string $s]
    exp_send -i $s "$result\r"
}

proc cmd_previous {} {
    global history histslot

    set histslot [ expr $histslot - 1 ]
    .cmd.e delete 0 end
    .cmd.e insert 0 [lindex $history $histslot]
}

proc cmd_next {} {
    global history histslot
    
    incr histslot
    .cmd.e delete 0 end
    .cmd.e insert 0 [lindex $history $histslot]
}

proc getconfiginfo {} {
    global env

    if { ! [info exists env(BUILDMANAGER_DIR)] } {
	set env(BUILDMANAGER_DIR) ~/.buildmanager
    }
    set fd [open "|domainname" "r" ]
    gets $fd domain
    close $fd

    set configfiles [list 	$env(BUILDMANAGER_DIR)/lib/system.cfg	\
    			 	$env(BUILDMANAGER_DIR)/lib/site.cfg	\
    			 	$env(BUILDMANAGER_DIR)/lib/$domain.cfg \
				~/.buildmanagerrc ]

    foreach f $configfiles {
	if { [file exists $f] } {
	    #puts "getting config info from $f"
	    uplevel #0 "source $f"
	}
    }
}

# ----------------------------------------------------------------------
# mainline...
# ----------------------------------------------------------------------

proc init {} {
    global argv env spawn_id history histslot expect_out pending pending2
    global os_dat sw_dat
    global promptre product version 
    global debug_state
       
    if { [lindex $argv 0] == "-debug_state" } {
	set argv [lrange $argv 1 end]
	set debug_state 1
    } else {
	set debug_state 0
    }
    if { [lindex $argv 0] == "-verbose" } {
	set argv [lrange $argv 1 end]
    } else {
	log_user 0
    }

    getconfiginfo

    if { [llength $argv ] > 0} {
	set product [lindex $argv 0]
    } 
    if { [llength $argv ] > 1} {
	set version [lindex $argv 1]
    }
    # puts "product $product version $version"

    set history {}
    set histslot 0

    menubar_gui .menubar
    fill_in_cmd_menu .menubar
    customcmd_gui .cmd
    frame .flavors
    vscrollframe .hosts

    pack .menubar .cmd .flavors -side top -expand 0 -fill x
    pack .hosts -side top -expand 1 -fill both

    updateflavorbuttons .flavors .hosts.f
    getlogininfo "Initial login"
    update
    updatehostwindows .hosts.f
    update
}

proc expect_loop {} {
    global argv env spawn_id history histslot expect_out pending pending2
    global os_dat sw_dat
    global promptre cmdstartre cmdfailre cmdnevermindre questionre
    global sessionlist
    global debug_state

    expect {
	-i sessionlist -re $cmdstartre { 
	    set s $expect_out(spawn_id)

	    if $debug_state {
	        puts "saw command start string:"
		puts "$expect_out(0,string)"
	    }

	    set cmd  $expect_out(1,string)
	    set args $expect_out(2,string)

	    if { [ regexp { ([^- =]+) } $args match first ] } {
		 # if we have an argument with no dashes or equals...
		 set target $first
	    } else {
		 set target "all"
	    }
	    if { ![info exists pending2($s)] || ![regexp -- {-make-} $pending2($s)]} {
	        update_state "$cmd-$target"
	        set pending2($s) "setstate \"$cmd-$target-OK\""
	    } else {
		update_bytes
	    }
	    exp_continue
	}
	-i sessionlist -re $cmdfailre {
	    set s $expect_out(spawn_id)
	    if { [info exists pending2($s)] } {
		if $debug_state {
		    puts "I think $pending2($s) failed because I saw:"
		    puts "$expect_out(0,string)"
		}
	        regsub -- {-OK} $pending2($s) {-Failed} pending2($s)
	    }
	    update_bytes
	    exp_continue
	}
	-i sessionlist -re $cmdnevermindre {
	    set s $expect_out(spawn_id)
	    if { [info exists pending2($s)] } {
		if $debug_state {
		    puts "I think $pending2($s) succeeded after all because I saw:"
		    puts "$expect_out(0,string)"
		}
	        regsub -- {-Failed} $pending2($s) {-OK} pending2($s)
	    }
	    update_bytes
	    exp_continue
	}
	-i sessionlist -re $questionre {
	    set s $expect_out(spawn_id)
	    if { [info exists pending2($s)] } {
		set state $sw_dat(state,$s)
		setstatus $s Question
		if [regexp {(.*-Question-)([0-9]+)$} $state match pre num] {
		    update_state "${pre}[expr $num + 1]"
		} else {
		    update_state "${state}-Question-1"
		}
	    } else {
	        update_status Question
	    }
	    exp_continue
	}
	-i sessionlist -re $promptre {
	    update_status Ready
	    exp_continue
	}
	-i sessionlist -re "\[\r\n\]+" {
	    update_status Running
	    exp_continue
	}
	-i sessionlist -re "\[^\r\n\]+" { 
	    update_bytes
	    exp_continue
	}
	-i sessionlist timeout {
	    flush_sent $sw_dat(s2w,$expect_out(spawn_id))
	    flush_rcvd $sw_dat(s2w,$expect_out(spawn_id))
	    exp_continue
	}
	-i sessionlist eof {
	    if [drop_session $expect_out(spawn_id)] exp_continue
	}
    }
}

proc error_dialog {routine message} {
    global errorInfo

    set errortolist $errorInfo
puts $errortolist
    set res [tk_dialog .error "Error!" "Error in $routine: $message" {} 0 "Ok" "Info" "Exit" ]
    if {$res == 1} {
	puts $errortolist
    }
    if {$res == 2} {
	puts $errortolist
	exit
    }
}

proc main {} {
    # make backspace and delete identical in entry widgets
    bind Entry <Delete> [bind Entry <BackSpace>]
    init 
    while [ catch expect_loop result] {
	update
	error_dialog expect_loop $result 
    }
    exit
}

main
